#
# Started from zle or from command line
#

emulate -LR zsh
setopt extendedglob typesetsilent

autoload __zcmdr-process-buffer __zcmdr-usetty-wrapper __zcmdr-list __zcmdr-list-input __zcmdr-list-draw
autoload __zcmdr_uizcm_last_n_git_log __zcmdr_uizcm_git_modified

[[ "${ZCMDR[stdlib_sourced]}" != "1" ]] && source "${ZCMDR_REPO_DIR}/lib/stdlib.lcmdr"

##
## Main code
##

# Measure and limit generation time
typeset -F SECONDS=0.0
local -F start_seconds=$SECONDS

local limit_seconds
zstyle -s ":plugin:zcommodore" time_limit limit_seconds || limit_seconds="500"
[[ "$limit_seconds" != <-> ]] && limit_seconds="500"

#
# Handler functions
#

__zcmdr_action_edit_file_cd() {
    local id="$1" ts="$2" cmd="$3" active_path="$4" file="$5"
    __zcmdr_stdlib_to_cmd_line "cd ${(q)active_path}; $cmd ${(q)file}"
}

__zcmdr_action_edit_file_abs() {
    local id="$1" ts="$2" cmd="$3" active_path="$4" file="$5"
    __zcmdr_stdlib_to_cmd_line "$cmd ${(q)active_path}/${(q)file}"
}

__zcmdr_action_git_diff_file_abs() {
    local id="$1" ts="$2" cmd="$3" active_path="$4" file="$5"
    __zcmdr_stdlib_to_cmd_line "git -C ${(q)active_path} diff ${(q)file}"
}

__zcmdr_action_file_cd() {
    local id="$1" ts="$2" cmd="$3" active_path="$4" file="$5"

    __zcmdr_stdlib_resolve_path "$active_path" "$file"
    local dir="${(q)reply[1]}" file="${(q)reply[2]}"

    __zcmdr_stdlib_to_cmd_line "cd $dir"
}

__zcmdr_action_backup() {
    local id="$1" ts="$2" cmd="$3" active_path="$4" file="$5" dest

    zstyle -s ":plugin:zcommodore" backup_dir dest || dest="$HOME/.backup"

    __zcmdr_stdlib_resolve_path "$active_path" "$file"
    local dir="${(q)reply[1]}" file="${(q)reply[2]}"

    __zcmdr_stdlib_get_date_and_time_string
    __zcmdr_stdlib_to_cmd_line "mkdir -p $dest; cp -vf $dir/$file $dest/${file}_$REPLY"
}

__zcmdr_action_git_history() {
    local id="$1" ts="$2" cmd="$3" active_path="$4" file="$5" dest
    __zcmdr_stdlib_to_cmd_line "git -C ${(q)active_path} log --follow -p -- ${(q)file}"
}

__zcmdr_action_git_ahistory() {
    local id="$1" ts="$2" cmd="$3" active_path="$4" file="$5" dest

    __zcmdr_stdlib_to_cmd_line "cmdr_ahistory ${(q)ZCMDR[current_project]} ${(q)active_path} ${(q)file}"
}

#
# Business logic follows
#

local curcontext=":zle:$WIDGET"
local MATCH MBEGIN MEND
typeset -a OUTPUT
integer LINE_COUNT

#
# Establish if the project is Git
#

local repo_root_dir
integer IS_GIT=0 IS_HG=0
repo_root_dir="$( git -C "${ZCMDR[current_repo]}" rev-parse --show-toplevel 2>/dev/null )"
if [[ -n "$repo_root_dir" ]]; then
    IS_GIT=1
else
    repo_root_dir="$( hg -R "${ZCMDR[current_repo]}" root 2>/dev/null )"
    [[ -n "$repo_root_dir" ]] && IS_HG=1
fi

#
# General zstyles
#

local selected_editor cd_at_edit
zstyle -s ":plugin:zcommodore" editor selected_editor || selected_editor="${EDITOR:-vim}"
zstyle -b ":plugin:zcommodore" cd_at_edit cd_at_edit || cd_at_edit="yes"

#
# Common variables
#

integer idx         # When iterating arrays
integer size        # Size of iterated array
local -a gitcmd     # Git command to be run
local -a gitout     # Unprocessed git output
local -a gitout2    # Processed git output
local entry         # Single entry
local -a arrentry   # Single entry (e.g. line output from Git) splitted into fields

#
# Initialization
#

OUTPUT+=( "" )
LINE_COUNT+=1
ZCMDRLIST_NONSELECTABLE_ELEMENTS+=( "$LINE_COUNT" )

#
# Last N git commits
#

__zcmdr_uizcm_last_n_git_log

#
# List of modified files
#

OUTPUT+=( "" )
LINE_COUNT+=1
ZCMDRLIST_NONSELECTABLE_ELEMENTS+=( "$LINE_COUNT" )

__zcmdr_uizcm_git_modified

#
# Generation time
#

local ZCMDRLIST_GENERATION_TIME="$(( SECONDS - start_seconds ))"
ZCMDRLIST_GENERATION_TIME="${ZCMDRLIST_GENERATION_TIME[1,5]}"

#
# Invoke the list, handle outcome
#

local ZCMDRLIST_WRAPPER_BIT=""
__zcmdr-usetty-wrapper __zcmdr-list-wrapper "${OUTPUT[@]}" "$ZCMDRLIST_GENERATION_TIME"

zle && zle .redisplay

if [ -z "$ZCMDRLIST_WRAPPER_BIT" ]; then
    return 1
fi

# ID, data1, data2, data3, data4
if __zcmdr_stdlib_decode_hyperlink "$ZCMDRLIST_WRAPPER_BIT"; then
    local id="${reply[1]}" ts="${reply[2]}" cmd="${reply[3]}" active_path="${reply[4]}" file="${reply[5]}"
    if [ -n "${ZCMDR_ACTION_IDS_TO_HANDLERS[$id]}" ]; then
        # Call the handled with all hyper-link data
        "${ZCMDR_ACTION_IDS_TO_HANDLERS[$id]}" "$id" "$ts" "$cmd" "$active_path" "$file"
    fi
fi

return 0

# vim:ft=zsh
