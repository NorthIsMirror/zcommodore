#
# Started from zle or from command line
#

[[ -o interactivecomments ]] && ZCMDR[INTERACTIVE_COMMENTS]="1" || ZCMDR[INTERACTIVE_COMMENTS]="0"

emulate -LR zsh
setopt extendedglob typesetsilent

autoload __zcmdr-process-buffer __zcmdr-usetty-wrapper __zcmdr-list __zcmdr-list-input __zcmdr-list-draw
autoload __zcmdr_uizcm_last_n_git_log __zcmdr_uizcm_git_modified __zcmdr_action_git_open_commit
autoload __zcmdr_uizcm_last_nprojects __zcmdr_uizcm_git_header

[[ "${ZCMDR[stdlib_sourced]}" != "1" ]] && source "${ZCMDR_REPO_DIR}/lib/stdlib.lcmdr"

##
## Main code
##

# Measure and limit generation time
typeset -F SECONDS=0.0
local -F start_seconds

local limit_seconds
zstyle -s ":plugin:zcommodore" time_limit limit_seconds || limit_seconds="500"
[[ "$limit_seconds" != <-> ]] && limit_seconds="500"

#
# Handler functions
#

__zcmdr_action_edit_file_cd() {
    local id="$1" ts="$2" cmd="$3" active_path="$4" file="$5"
    __zcmdr_stdlib_to_cmd_line "cd ${(q)active_path}; $cmd ${(q)file}"
}

__zcmdr_action_edit_file_abs() {
    local id="$1" ts="$2" cmd="$3" active_path="$4" file="$5"
    __zcmdr_stdlib_to_cmd_line "$cmd ${(q)active_path}/${(q)file}"
}

__zcmdr_action_git_diff_file_abs() {
    local id="$1" ts="$2" cmd="$3" active_path="$4" file="$5"
    __zcmdr_stdlib_to_cmd_line "git -C ${(q)active_path} diff ${(q)file}"
}

__zcmdr_action_file_cd() {
    local id="$1" ts="$2" cmd="$3" active_path="$4" file="$5"

    __zcmdr_stdlib_resolve_path "$active_path" "$file"
    local dir="${(q)reply[1]}" file="${(q)reply[2]}"

    __zcmdr_stdlib_to_cmd_line "cd $dir"
}

__zcmdr_action_backup() {
    local id="$1" ts="$2" cmd="$3" active_path="$4" file="$5" dest

    zstyle -s ":plugin:zcommodore" backup_dir dest || dest="$HOME/.backup"

    __zcmdr_stdlib_resolve_path "$active_path" "$file"
    local dir="${(q)reply[1]}" file="${(q)reply[2]}"

    __zcmdr_stdlib_get_date_and_time_string
    __zcmdr_stdlib_to_cmd_line "cmdr_bdir -s; cp -vf $dir/$file ${(q)dest}/${file}_$REPLY"
}

__zcmdr_action_git_history() {
    local id="$1" ts="$2" cmd="$3" active_path="$4" file="$5"
    __zcmdr_stdlib_to_cmd_line "git -C ${(q)active_path} log --follow -p -- ${(q)file}"
}

__zcmdr_action_git_ahistory() {
    local id="$1" ts="$2" cmd="$3" active_path="$4" file="$5"

    __zcmdr_stdlib_to_cmd_line "cmdr_ahistory ${(q)active_path} . ${(q)file}"
}

__zcmdr_action_git_store_as_object() {
    local id="$1" ts="$2" cmd="$3" active_path="$4" file="$5"

    __zcmdr_stdlib_to_cmd_line "cmdr_store_as_object ${(q)active_path} . ${(q)file}"
}

__zcmdr_action_git_same_files() {
    local id="$1" ts="$2" cmd="$3" active_path="$4" sha="$5"

    __zcmdr_stdlib_to_cmd_line "cmdr_same_files ${(q)active_path} $sha"
}

__zcmdr_action_git_same_files_e() {
    local id="$1" ts="$2" cmd="$3" active_path="$4" sha="$5"

    __zcmdr_stdlib_to_cmd_line "cmdr_same_files -e ${(q)active_path} $sha"
}

__zcmdr_action_git_same_author() {
    local id="$1" ts="$2" cmd="$3" active_path="$4" author="$5"
    __zcmdr_stdlib_to_cmd_line "git -C ${(q)active_path} log --author=${(q)author} --date=short --pretty=format:'%Cgreen%cd %h %Creset%s'"
}

__zcmdr_action_git_diff() {
    local id="$1" ts="$2" cmd="$3" active_path="$4" sha="$5"

    __zcmdr_stdlib_to_cmd_line "git -C ${(q)active_path} log -p -1 --word-diff=color $sha"
}

__zcmdr_action_zconvey_zcmdr_g() {
    local id="$1" ts="$2" cmd="$3" active_path="$4" zconvey="$5"

    if [[ "$zconvey" = "yes" ]]; then
        if ! type zc 2>/dev/null 1>&2; then
            __zcmdr_stdlib_to_cmd_line "cd ${(q)active_path}; zcmdr -g; echo \"\\nZconvey is not installed: http://github.com/psprint/zconvey\""
        else
            __zcmdr_stdlib_to_cmd_line "cd ${(q)active_path}; zcmdr -g; zc-all cd ${(q)active_path}\; zcmdr"
        fi
    else
        __zcmdr_stdlib_to_cmd_line "cd ${(q)active_path}; zcmdr -g"
    fi
}

#
# Business logic follows
#

local curcontext=":zle:$WIDGET"
local MATCH MBEGIN MEND

#
# General zstyles
#

local selected_editor cd_at_edit
zstyle -s ":plugin:zcommodore" editor selected_editor || selected_editor="${EDITOR:-vim}"
zstyle -b ":plugin:zcommodore" cd_at_edit cd_at_edit || cd_at_edit="yes"

#
# Variables
#

local -a reply      # Output of module
local -a reply2     # Size of the output
local -a reply3     # Module's nonselectables
local -a reply4     # Module's hops

# Last N projects
local -a proj_output proj_nonselectables proj_hops
local -a prev_proj_nonselectables prev_proj_hops
integer proj_size prev_proj_size

# Last N commits
local -a log_output log_nonselectables log_hops
local -a prev_log_nonselectables prev_log_hops
integer log_size prev_log_size

# Modified files
local -a modified_output modified_nonselectables modified_hops
local -a prev_modified_nonselectables prev_modified_hops
integer modified_size prev_modified_size

#
# Parameters for modules
#

local log_count

# Log size already set before? Stick to
# it and don't read Zstyle only if it's
# altered, not previous Zstyle value
#
# This allows users to change the log size
# setting without restarting Zsh provided
# they have log size as it was previously
# in Zstyle
if [[ "${+ZCMDR[LOG_SIZE]}" = "1" && "${ZCMDR[LOG_SIZE]}" != "${ZCMDR[LOG_SIZE_INITIAL]}" ]]; then
    log_count="${ZCMDR[LOG_SIZE]}"
else
    zstyle -s ":plugin:zcommodore" log_count log_count || log_count="7"
    [[ "$log_count" != <-> ]] && log_count="7"
    ZCMDR[LOG_SIZE_INITIAL]="$log_count"
fi

local nprojects
zstyle -s ":plugin:zcommodore" nprojects nprojects || nprojects="5"
[[ "$nprojects" != <-> ]] && nprojects="5"
[[ "$nprojects" = "0" ]] && nprojects="1"

#
# Own copy of current_* ZCMDR fields, to be able
# to switch without switching session's state
#

local current_project="${ZCMDR[current_project]}"
local current_repo="${ZCMDR[current_repo]}"
local current_tag_file="${ZCMD[current_tag_file]}"

###
### REGENERATION REQUEST LOOP ###
###

local REGENERATE="" REGENERATE_ARG=""

while (( 1 )); do

# Measure generation time
start_seconds=$SECONDS

#
# Establish if the project is Git
#

if [[ -z "$REGENERATE" || "$REGENERATE" = *,switch_project,* ||
        "$REGENERATE" = *,switch_project_g,* || "$REGENERATE" = *,all,* ]]
then

    local -a input_data
    if [[ "$REGENERATE" = *,switch_project,* || "$REGENERATE" = *,switch_project_g,* ]]; then
        input_data=( "${(@f)"$(<$REGENERATE_ARG)"}" )
    elif [[ -n "$REGENERATE" ]]; then
        input_data=( "${(@f)"$(<$HOME/.config/zcommodore/current_project)"}" )
    fi

    if [[ -n "$REGENERATE" ]]; then
        current_project="${input_data[1]}"
        current_repo="${input_data[2]}"
        current_tag_file="${input_data[3]}"

        if [[ "$REGENERATE" = *,switch_project_g,* ]]; then
            ZCMDR[current_project]="$current_project"
            ZCMDR[current_repo]="$current_repo"
            ZCMDR[current_tag_file]="$current_tag_file"
        fi
    fi

    local repo_root_dir
    integer IS_GIT=0 IS_HG=0
    repo_root_dir="$( git -C "$current_repo" rev-parse --show-toplevel 2>/dev/null )"
    if [[ -n "$repo_root_dir" ]]; then
        IS_GIT=1
    else
        repo_root_dir="$( hg -R "$current_repo" root 2>/dev/null )"
        [[ -n "$repo_root_dir" ]] && IS_HG=1
    fi
fi

#
# Header
#

if [[ -z "$REGENERATE" || "$REGENERATE" = *,header,* || "$REGENERATE" = *,all,* ]]; then
    __zcmdr_uizcm_git_header

    header_output=( "${reply[@]}" )
    header_size="$reply2"
    header_nonselectables=( "${reply3[@]}" )
    header_hops=( "${reply4[@]}" )
fi

#
# Last N projects
#

if [[ -z "$REGENERATE" || "$REGENERATE" = *,projects,* || "$REGENERATE" = *,all,* ]]; then
    __zcmdr_uizcm_last_nprojects "$nprojects"

    proj_output=( "${reply[@]}" )
    proj_size="$reply2"
    proj_nonselectables=( "${reply3[@]}" )
    proj_hops=( "${reply4[@]}" )
fi

#
# Last N commits
#

if [[ -z "$REGENERATE" || "$REGENERATE" = *,log,* || "$REGENERATE" = *,all,* ]]; then

    [[ "$REGENERATE" = *,log,* && "$REGENERATE_ARG" = "plus" ]] && (( log_count+=5 ))
    [[ "$REGENERATE" = *,log,* && "$REGENERATE_ARG" = "minus" ]] && {
            (( log_count=log_count-5 ))
            (( log_count < 1 )) && log_count="1"
    }

    ZCMDR[LOG_SIZE]="$log_count"

    if (( IS_GIT )); then
        __zcmdr_uizcm_last_n_git_log "$log_count"

        log_output=( "${reply[@]}" )
        log_size="$reply2"
        log_nonselectables=( "${reply3[@]}" )
        log_hops=( "${reply4[@]}" )
    fi
fi

#
# List of modified files
#

if [[ -z "$REGENERATE" || "$REGENERATE" = *,modified,* || "$REGENERATE" = *,all,* ]]; then

    if (( IS_GIT )); then
        __zcmdr_uizcm_git_modified

        modified_output=( "${reply[@]}" )
        modified_size="$reply2"
        modified_nonselectables=( "${reply3[@]}" )
        modified_hops=( "${reply4[@]}" )
    fi
fi

#
# Store all results into OUTPUT, ZCMDRLIST_NONSELECTABLE_ELEMENTS, ZCMDRLIST_HOP_INDEXES
#

ZCMDRLIST_NONSELECTABLE_ELEMENTS=()
ZCMDRLIST_HOP_INDEXES=()

local -a OUTPUT output nonselectables hops
local -a prev_nonselectables prev_hops
local n var_name
integer LINE_COUNT size

OUTPUT=( )
LINE_COUNT=0

for n in "header" "proj" "log" "modified"; do
    # Get output
    var_name="${n}_output"
    output=( "${(PA@)var_name}" )

    # Get output size
    var_name="${n}_size"
    size="${(P)var_name}"

    # Get nonselectables
    var_name="${n}_nonselectables"
    nonselectables=( "${(PA@)var_name}" )

    # Get hops
    var_name="${n}_hops"
    hops=( "${(PA@)var_name}" )

    # Get previous nonselectables
    var_name="prev_${n}_nonselectables"
    prev_nonselectables=( "${(PA@)var_name}" )

    # Get previous hops
    var_name="prev_${n}_hops"
    prev_hops=( "${(PA@)var_name}" )

    OUTPUT+=( "" )
    LINE_COUNT+=1
    ZCMDRLIST_NONSELECTABLE_ELEMENTS+=( "$LINE_COUNT" )

    # Remove previous non-selectables and hops,
    # added on previous creation of this section
    ZCMDRLIST_NONSELECTABLE_ELEMENTS=( "${ZCMDRLIST_NONSELECTABLE_ELEMENTS[@]:|prev_nonselectables}" )
    ZCMDRLIST_HOP_INDEXES=( "${ZCMDRLIST_HOP_INDEXES[@]:|prev_hops}" )

    # Translate returned indices to global ones
    nonselectables=( "${nonselectables[@]//(#b)([[:digit:]]##)/$(( ${match[1]} + LINE_COUNT ))}" )
    hops=( "${hops[@]//(#b)([[:digit:]]##)/$(( ${match[1]} + LINE_COUNT ))}" )

    # Add current hops
    ZCMDRLIST_NONSELECTABLE_ELEMENTS+=( "${nonselectables[@]}" )
    ZCMDRLIST_HOP_INDEXES+=( "${hops[@]}" )

    # Alter current index if size of section was changed
    # - using *_size, prev_*_size parameters
    if [[ "$n" = "log" && "$REGENERATE" = *,log,* ]]; then
        integer delta=$(( log_size-prev_log_size ))
        ZCMDRLIST_CURRENT_IDX=$(( ZCMDRLIST_CURRENT_IDX + delta ))
    fi

    # Also store the indices into prev_* arrays
    var_name="prev_${n}_nonselectables"
    : "${(PA)var_name::=${nonselectables[@]}}";
    var_name="prev_${n}_hops"
    : "${(PA)var_name::=${hops[@]}}";
    var_name="prev_${n}_size"
    : "${(P)var_name::=${size}}";

    OUTPUT+=( "${output[@]}" )
    LINE_COUNT+=size
done

# Reset regeneration variables
REGENERATE=""
REGENERATE_ARG=""

#
# Generation time
#

local ZCMDRLIST_GENERATION_TIME="$(( SECONDS - start_seconds ))"
ZCMDRLIST_GENERATION_TIME="${ZCMDRLIST_GENERATION_TIME[1,5]}"

#
# Invoke the list, handle outcome
#

local ZCMDRLIST_WRAPPER_BIT=""
__zcmdr-usetty-wrapper __zcmdr-list-wrapper "${OUTPUT[@]}" "$ZCMDRLIST_GENERATION_TIME"

if [ -z "$ZCMDRLIST_WRAPPER_BIT" ]; then
    zle && zle .redisplay
    return 1
fi

# ID, data1, data2, data3, data4
if __zcmdr_stdlib_decode_hyperlink "$ZCMDRLIST_WRAPPER_BIT"; then
    local id="${reply[1]}" ts="${reply[2]}" cmd="${reply[3]}" active_path="${reply[4]}" file="${reply[5]}"
    if [[ -z "$id" ]]; then
        REGENERATE="$ts"
        REGENERATE_ARG="$active_path"
    elif [[ -n "${ZCMDR_ACTION_IDS_TO_HANDLERS[$id]}" ]]; then
        zle && zle .redisplay
        # Call the handled with all hyper-link data
        "${ZCMDR_ACTION_IDS_TO_HANDLERS[$id]}" "$id" "$ts" "$cmd" "$active_path" "$file"
        break
    fi
fi

### REGENERATION REQUEST LOOP ###
done

return 0

# vim:ft=zsh
