emulate -LR zsh
setopt extendedglob typesetsilent

[[ -z "${fg_bold[green]}" ]] && builtin autoload -Uz colors && colors

__zcmdr_usage_zcm_feature() {
    print -- "Feature management tool. You can EDIT files belonging to feature (with"
    print -- "editor from e.g. \$EDITOR variable), CREATE feature from set of files"
    print -- "or from *commit*, UPDATE files of a feature and DELETE whole feature."
    print
    print -- "${fg_bold[green]}Usage: zcm-feature [-q] [-v] {feature-name}${reset_color}"
    print -- "${fg_bold[green]}       zcm-feature [-q] [-v] {-l|--list} [project name]${reset_color}"
    print -- "${fg_bold[green]}       zcm-feature [-q] [-v] {-c|--create} {feature-name} {file1} {file2} ...${reset_color}"
    print -- "${fg_bold[green]}       zcm-feature [-q] [-v] {-C|--create-from-commits} {feature-name} {file1} {file2} ...${reset_color}"
    print -- "${fg_bold[green]}       zcm-feature [-q] [-v] {-a|--add} {feature-name} {file1} {file2} ...${reset_color}"
    print -- "${fg_bold[green]}       zcm-feature [-q] [-v] {-d|--delete} {feature-name} {file1} {file2} ...${reset_color}"
    print -- "${fg_bold[green]}       zcm-feature [-q] [-v] {-D|--delete-feature} {feature-name}${reset_color}"
    print -- "${fg_bold[green]}       zcm-feature [-q] [-v] {-S|--set-commits} {feature-name} {commit SHA} [commit SHA] ...${reset_color}"
    print
    print -- "-h|--help                This message"
    print -- "-l/--list                List features of current project and allow selection (for editing)"
    print -- "-c/--create              Create new feature from supplied files"
    print -- "-C/--create-from-commits Create new feature from files of given commits, attach the commits"
    print -- "-a/--add                 Add given files to given feature"
    print -- "-d/--delete              Delte given files from given feature"
    print -- "-D/--delete-feature      Forget given feature"
    print -- "-S/--set-commits         Attach given commits to given feature, replacing previous ones"
    print
    print -- "-q/--quiet      Operate without outputting messages"
    print -- "-v/--verbose    Print more status messages"
    return 0
}

local -A opthash
zparseopts -D -A opthash l -list c -create C -create-from-commits a -add d -delete D -delete-feature S -set-commits q -quiet v -verbose h -help || { __zcmdr_usage_zcm; return 1; }

integer list=0 create=0 create_from_commits=0 add=0 delete=0 delete_feature=0 set_commits=0 quiet=0 verbose=0

# Help
(( ${+opthash[-h]} + ${+opthash[--help]} )) && { __zcmdr_usage_zcm_feature; return 0; }

(( list = ${+opthash[-l]} + ${+opthash[--list]} ))
(( create = ${+opthash[-c]} + ${+opthash[--create]} ))
(( create_from_commits = ${+opthash[-C]} + ${+opthash[--create-from-commits]} ))
(( add = ${+opthash[-a]} + ${+opthash[--add]} ))
(( delete = ${+opthash[-d]} + ${+opthash[--delete]} ))
(( delete_feature = ${+opthash[-D]} + ${+opthash[--delete-feature]} ))
(( set_commits = ${+opthash[-S]} + ${+opthash[--set-commits]} ))
(( quiet = ${+opthash[-q]} + ${+opthash[--quiet]} ))
(( verbose = ${+opthash[-v]} + ${+opthash[--verbose]} ))

[[ "${ZCMDR[stdlib_sourced]}" != "1" ]] && source "${ZCMDR_REPO_DIR}/lib/stdlib.lcmdr"

if (( list + create + create_from_commits + add + delete + delete_feature + set_commits > 1 )); then
    print "Conflicting options given, please use single operation specifier (like -c, -C, -a, etc.)"
    return 2
fi

local features_path="$ZCMDR_CONFIG_DIR/var/features"
[[ ! -d "$features_path" ]] && command mkdir -p "$features_path"
integer retcode

#
# Functions
#

__zcmdr_verify_feature() {
    local feature="$1"

    if [[ "$feature" != [[:alnum:]_-]## ]]; then
        print "Improper feature name: \`$feature'. Allowed are letters, _, - and digits."
        return 3
    fi

    local feature_file="${features_path}/${feature}.conf"

    if [[ ! -d "${ZCMDR[current_project]}" ]]; then
        print "Current project points to incorrect path, aborting: \`${ZCMDR[current_project]}'"
        print "(consider running zcm in a project directory or zcm -l)"
        return 4
    fi

    if [[ "$2" != "can_exist" && "$2" != "must_exist" && -f "$feature_file" ]]; then
        local -a entries
        entries=( "${(@f)"$(<$feature_file)"}" )

        local project_path="${entries[2]/(#s)$HOME/~}"
        print "Feature \`$feature' already exists, belongs to project ${fg_bold[green]}${project_path}${reset_color}"
        return 5
    fi

    if [[ "$2" = "must_exist" && ! -f "$feature_file" ]]; then
        print "Feature \`$feature' doesn't exist (at any project)"
        return 6
    fi

    return 0
}

#
# List
#

if (( list )); then
    local -a features
    features=( "${features_path}"/*.conf(N) )
    if [[ -z "${features[1]}" ]]; then
        print "No features currently defined"
        return 0
    fi

    local -a found entries
    local pth project_query="$1"
    for pth in "${features[@]}"; do
        entries=( "${(@f)"$(<$pth)"}" )
        if [[ -n "$project_query" && "${entries[2]}" = *$~project_query* ]]; then
            found+=( "$pth" )
        elif [[ -z "$project_query" && "${entries[2]}" = "${ZCMDR[current_project]}" ]]; then
            found+=( "$pth" )
        fi
    done

    if [[ -z "${found[1]}" ]]; then
        print "Project ${fg_bold[green]}${ZCMDR[current_project]}${reset_color} doesn't have features defined"
        return 0
    fi

    local -a files commits
    for pth in "${found[@]}"; do
        entries=( "${(@f)"$(<$pth)"}" )

        local feature="${pth:t:r}"
        print -- "${fg_bold[magenta]}$feature${reset_color}"

        local project_name="${entries[2]}"
        project_name="${project_name:t:r}"

        if [[ -n "$project_query" ]]; then
            print -- "(${fg_bold[red]}$project_name${reset_color})"
        fi

        files=( "${(z@)entries[3]}" )
        if [[ "${files[1]}" != "files" ]]; then
            print -- "Improper 3rd line in the feature file, should begin with \`files' string"
        elif [[ "${#files}" -gt 1 ]]; then
            shift files
            print -- "${fg_bold[green]}Files${reset_color}:"
            print -rl -- "${(Q)files[@]}"
        fi

        commits=( "${(z@)entries[4]}" )
        if [[ "${commits[1]}" != "commits" ]]; then
            print -- "Improper 4th line in the feature file, should begin with \`commits' string"
        elif [[ "${#commits}" -gt 1 ]]; then
            shift commits
            print -- "${fg_bold[green]}Commits${reset_color}:"
            print -rl -- "${(Q)commits[@]}"
        fi

        print
    done
    return 0
fi

#
# Create
#

if (( create )); then
    if [[ "$#" -lt "2" ]]; then
        print "At least 2 arguments are needed, feature to create and a file to attach to the feature"
        return 7
    fi

    local feature="$1"
    shift

    local -a files
    files=( "$@" )

    local feature_file="${features_path}/${feature}.conf"

    __zcmdr_verify_feature "$feature"
    retcode=$?
    (( retcode )) && return $retcode

    local project_line="${ZCMDR[current_project]}"
    files=( "${(qq)files[@]}" )
    local files_line="files ${files[*]}"
    local commits_line="commits"

    print -rl -- "# Feature \`$feature'" >! "$feature_file"
    print -rl -- "$project_line" >>! "$feature_file"
    print -rl -- "$files_line" >>! "$feature_file"
    print -rl -- "$commits_line" >>! "$feature_file"

    print -- "Feature ${fg_bold[green]}$feature${reset_color} created (project: ${fg_bold[green]}${project_line:t:r}${reset_color}), has the files / directories:"
    print -rl -- "${(Q)files[@]}"
    return 0
fi

#
# Create from commits
#
# This is specific as it copies files from commits
# as feature's original files. This doesn't happen
# when setting commits of a feature (-S).
#

if (( create_from_commits )); then
    if [[ "$#" -lt "2" ]]; then
        print "At least 2 arguments are needed, name of feature to create and a commit SHA"
        return 8
    fi

    local feature="$1"
    shift

    local -a commits
    commits=( "$@" )

    local feature_file="${features_path}/${feature}.conf"

    __zcmdr_verify_feature "$feature"
    retcode=$?
    (( retcode )) && return $retcode

    local root_dir="${ZCMDR[current_repo]}"

    [[ ! -d "$root_dir" ]] && { print "Repository dir doesn't exist or isn't directory (\`$root_dir')"; return 9; }

    local cmt
    local -a files
    local -aU save_files
    if [[ -d "$root_dir"/.git ]]; then
        for cmt in "${commits[@]}"; do
            # Get list of files (3 steps) of a commit
            files=( ${(f)"$( git -C "$root_dir" show --name-status --no-renames "$cmt" )"} )
            files=( "${(@M)files:#((#s)[ADM][ADM]#[[:space:]]##*|(#s)[ ][ADM][[:space:]]##*)}" )
            files=( "${files[@]/(#b)(#s)[[:alpha:]]##[[:space:]]##(*)(#e)/${match[1]}}" )

            save_files+=( "${files[@]}" )
        done
    elif [[ -d "$root_dir"/.hg ]]; then
        for cmt in "${commits[@]}"; do
            # Get list of files (3 steps) of a commit
            files=( ${(f)"$( hg --cwd "$root_dir" log -r "$cmt" -T {files}\\n )"} )

            save_files+=( "${files[@]}" )
        done
    else
        print "Cannot create feature from given commits â€“ project isn't Git nor Hg repository"
        return 10
    fi

    local project_line="${ZCMDR[current_project]}"
    files=( "${(qq)save_files[@]}" )
    local files_line="files ${files[*]}"
    commits=( "${(q)commits[@]}" )
    local commits_line="commits ${commits[*]}"

    print -rl -- "# Feature \`$feature'" >! "$feature_file"
    print -rl -- "$project_line" >>! "$feature_file"
    print -rl -- "$files_line" >>! "$feature_file"
    print -rl -- "$commits_line" >>! "$feature_file"

    print "Feature ${fg_bold[green]}\`$feature'${reset_color} created (project: ${fg_bold[green]}${project_line:t:r}${reset_color}) with files from the commit(s)"
    return 0
fi

if (( add )); then
    if [[ "$#" -lt "2" ]]; then
        print "At least 2 arguments are needed, feature to update and a file to attach to the feature"
        return 11
    fi

    local feature="$1"
    shift

    local -aU files
    files=( "$@" )

    __zcmdr_verify_feature "$feature" "can_exist"
    retcode=$?
    (( retcode )) && return $retcode

    local feature_file="${features_path}/${feature}.conf"
    local -a entries
    entries=( "${(@f)"$(<$feature_file)"}" )

    local project_line="${ZCMDR[current_project]}"

    if [[ "${entries[2]}" != "$project_line" ]]; then
        print "The feature \`$feature' belongs to project: ${fg_bold[green]}\`${entries[2]:t:r}'${reset_color}. Proceed with update? [y/n]"
        local answer="n"
        read -qs answer
        if [[ "$answer" = "n" ]]; then
            echo "Aborting.."
            return 12
        else
            project_line="${entries[2]}"
        fi
    fi

    # Split current files to keep them uniq
    local -a current
    current=( "${(z@)entries[3]}" )
    # z-flag can do tricks IIRC
    if [[ -z "${current[1]}" ]]; then
        current=( )
    else
        shift current
    fi

    files=( "${files[@]/(#s)$project_line\//}" )
    integer before_count="${#current}"
    files=( "${(qq)files[@]}" "${current[@]}" )
    integer after_count="${#files}"

    local files_line="files ${files[*]}"
    local commits_line="${entries[4]}"

    print -rl -- "# Feature \`$feature'" >! "$feature_file"
    print -rl -- "$project_line" >>! "$feature_file"
    print -rl -- "$files_line" >>! "$feature_file"
    print -rl -- "$commits_line" >>! "$feature_file"

    if (( quiet == 0 )); then
        if (( verbose == 1 )); then
            if [[ "$before_count" = "$after_count" ]]; then
                print -- "Feature ${fg_bold[green]}$feature${reset_color} remained the same (no new files):"
            else
                print -- "Feature ${fg_bold[green]}$feature${reset_color} updated, has the files / directories:"
            fi
            print -rl -- "${(Q)files[@]}"
        else
            if [[ "$before_count" = "$after_count" ]]; then
                print -- "Feature ${fg_bold[green]}$feature${reset_color} remained the same (no new files)"
            else
                print -- "Feature ${fg_bold[green]}$feature${reset_color} updated"
            fi
        fi
    fi
    return 0
fi

if (( delete )); then
    if [[ "$#" -lt "2" ]]; then
        print "At least 2 arguments are needed, feature to update and a file to remove from the feature"
        return 13
    fi

    local feature="$1"
    shift

    # Files to remove
    local -aU files
    files=( "$@" )

    __zcmdr_verify_feature "$feature" "can_exist"
    retcode=$?
    (( retcode )) && return $retcode

    local feature_file="${features_path}/${feature}.conf"
    local -a entries
    entries=( "${(@f)"$(<$feature_file)"}" )

    local project_line="${ZCMDR[current_project]}"

    if [[ "${entries[2]}" != "$project_line" ]]; then
        print "The feature \`$feature' belongs to project: ${fg_bold[green]}\`${entries[2]:t:r}'${reset_color}. Proceed with deletion of files? [y/n]"
        local answer="n"
        read -qs answer
        if [[ "$answer" = "n" ]]; then
            echo "Aborting.."
            return 14
        else
            project_line="${entries[2]}"
        fi
    fi

    # Split current files to keep them uniq
    local -a current
    current=( "${(z@)entries[3]}" )
    # z-flag can do tricks IIRC
    if [[ -z "${current[1]}" ]]; then
        current=( )
    else
        shift current
    fi

    files=( "${files[@]}" )

    local f f2
    integer before_count="${#current}" found_idx
    for f in "${files[@]}"; do
        f2="${f/(#s)$project_line\//}"
        f2="${(qq)f2}"
        f="${(qq)f}"

        # Absolute path
        found_idx="${current[(I)$f]}"
        if [[ "$found_idx" != "0" ]]; then
            (( quiet )) || echo "Removing ${(Q)f}..."
            current[found_idx]=()
        fi

        # Relative path
        found_idx="${current[(I)$f2]}"
        if [[ "$found_idx" != "0" ]]; then
            (( quiet )) || echo "Removing ${(Q)f2}..."
            current[found_idx]=()
        fi
    done

    integer after_count="${#current}"

    local files_line="files ${current[*]}"
    local commits_line="${entries[4]}"

    print -rl -- "# Feature \`$feature'" >! "$feature_file"
    print -rl -- "$project_line" >>! "$feature_file"
    print -rl -- "$files_line" >>! "$feature_file"
    print -rl -- "$commits_line" >>! "$feature_file"

    if (( quiet == 0 )); then
        [[ "$before_count" != "$after_count" || "$answer" = "y" ]] && print

        if (( verbose == 1 )); then
            if [[ "$before_count" = "$after_count" ]]; then
                print -- "Feature ${fg_bold[green]}$feature${reset_color} remained the same (no files deleted):"
            else
                print -- "Feature ${fg_bold[green]}$feature${reset_color} updated, has the files / directories:"
            fi
            print -rl -- "${(Q)current[@]}"
        else
            if [[ "$before_count" = "$after_count" ]]; then
                print -- "Feature ${fg_bold[green]}$feature${reset_color} remained the same (no files deleted)"
            else
                print -- "Feature ${fg_bold[green]}$feature${reset_color} updated (files deleted)"
            fi
        fi
    fi
    return 0
fi

if (( delete_feature )); then
    if [[ "$#" -ne "1" ]]; then
        print "Exactly one argument is needed: name of feature to delete"
        return 15
    fi

    local feature="$1"

    __zcmdr_verify_feature "$feature" "must_exist"
    retcode=$?
    (( retcode )) && return $retcode

    local feature_file="${features_path}/${feature}.conf"
    if (( quiet == 0 )); then
        local -a entries
        entries=( "${(@f)"$(<$feature_file)"}" )
        local project_path="${entries[2]/(#s)$HOME/~}"

        print "Are you sure want to delete ${fg_bold[green]}\`$feature'${reset_color} belonging to project ${fg_bold[green]}\`$project_path'${reset_color}? [y/n]"
        local answer="n"
        read -qs answer
        if [[ "$answer" = "y" ]]; then
            (( verbose )) && print "Removing feature \`$feature'..."
            command rm -f "$feature_file"
            print "Done."
        else
            print "Aborting."
        fi
    else
        (( verbose )) && print "Removing feature \`$feature'..."
        command rm -f "$feature_file"
        (( verbose )) && print "Done."
    fi

    return 0
fi

return 0

# vim:ft=zsh
